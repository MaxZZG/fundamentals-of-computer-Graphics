

\chapter{介绍}
\label{chap01}

“计算机图形学(Computer graphics)”一词描述了计算机创造和操纵图像的任何用途。本书介绍了算法和数学工具，可用于创建各种图像、逼真的视觉效果、信息丰富的技术插图或漂亮的计算机动画。图形可以是二维或三维的；图像可以是完全合成的，也可以通过对照片进行处理而生成。这本书是关于基础算法与数学的，特别是那些用来生成三维物体和景象的算法。

实际上，做计算机图形不可避免地需要了解特定的硬件、文件格式，通常还需要了解一两个图形API(参见第1.3节)。计算机图形学是一个快速发展的领域，所以对于该领域的学习是无止境的。因此，在这本书中，我们尽力避免依赖任何特定的硬件或API\footnote{API:应用程序接口(application program interface)}。我们也支持鼓励读者为其软件和硬件环境补充相关文档。幸运的是，计算机图形学有足够的标准术语和概念，本书的讨论应该很好地映射到大多数环境。

本章定义了计算机图形学的一些基本术语，并介绍了一些背景，以及与计算机图形学有关的资料来源。

\section{图形领域(Graphics Areas)}

在任何行业领域中硬性的分类都是不合理的，但大多数图形学研究者认同以下是计算机图形学核心领域:

\begin{itemize}
	\item \textbf{\textcolor{ForestGreen}{建模(Modeling)}}是以可存储在计算机上的方式处理形状和外观特性的数学规范。例如，一个咖啡杯可以被描述为一组有序的3D点，以及一些如何连接这些点的插值规则和一个描述光线如何与杯子相互作用的反射模型。
	
	\item \textbf{\textcolor{ForestGreen}{渲染(Rendering)}}是从艺术领域借鉴而来的术语，涉及到从三维计算机模型中创建着色图像。
	
	\item \textbf{\textcolor{ForestGreen}{动画(Animation)}}是一种通过图像序列创造运动幻象的技术。动画使用建模和渲染，但增加了如何随时间移动的关键问题，而这通常在基本建模和渲染中不会处理。
\end{itemize}

还有许多其他涉及计算机图形的领域，而它们是否属于核心图形领域，见仁见智。这些都将至少在正文中有所涉及。这些相关领域包括以下内容:

\begin{itemize}
	\item \textbf{\textcolor{ForestGreen}{用户交互(User interaction)}}涉及输入设备(如鼠标和平板电脑)、应用程序、图像中对用户的反馈以及其他感官反馈之间的界面。从历史上看，这一领域与图形学有关，主要是因为图形学研究人员最早接触到了现在无处不在的输入/输出设备。

	\item \textbf{\textcolor{ForestGreen}{虚拟现实(Virtual reality)}}试图让用户沉浸在一个三维虚拟世界中。这通常要求至少有立体图形和对头部运动的反应。对于真正的虚拟现实，还应该提供声音和力反馈。因为这一领域需要先进的3D图形和先进的显示技术，所以它通常与图形密切相关。

	\item \textbf{\textcolor{ForestGreen}{可视化(Visualization)}}试图通过视觉显示让用户深入了解复杂的信息。通常，在可视化问题中有很多图形问题需要解决。

	\item \textbf{\textcolor{ForestGreen}{图像处理(Image processing)}}涉及对二维图像的操作，在图形和视觉领域都有应用。

	\item \textbf{\textcolor{ForestGreen}{3D扫描(3D scanning)}}使用测距技术来创建测量的三维模型。这样的模型对于创造丰富的视觉图像很有帮助，而对这种模型的处理往往需要图形算法。

	\item \textbf{\textcolor{ForestGreen}{计算型摄影(Computational photography)}}是使用计算机图形、计算机视觉和图像处理方法，以实现拍摄物体、场景和环境的新方法。

\end{itemize}

\section{主要的应用领域(Major Applications)}

几乎任何工作都可以在一定程度上使用计算机图形，但计算机图形技术的主要用户包括以下行业:

\begin{itemize}
	\item \textbf{\textcolor{ForestGreen}{电子游戏(Video games)}}越来越多地使用复杂的3D建模和渲染算法。
	
	\item \textbf{\textcolor{ForestGreen}{动画片(Cartoons)}}通常是直接从3D模型中渲染出来的。许多传统的二维动画片使用由三维模型渲染的背景，这使得在不需要艺术家大量时间的情况下允许视点连续移动。
	
	\item \textbf{\textcolor{ForestGreen}{视觉特效(Visual effects)}}几乎使用所有类型的计算机图形学技术。几乎每部现代电影都使用数字合成技术，将背景与单独拍摄的前景叠加在一起。许多电影还使用三维建模和动画来创造合成环境、物体，甚至大多数观众永远不会怀疑的角色不是真实的。

	\item \textbf{\textcolor{ForestGreen}{动画电影(Animated films)}}使用了许多与视觉特效相同的技术，但不一定要以看起来图像更真实为目标。
	
	\item \textbf{\textcolor{ForestGreen}{计算机辅助设计和计算机辅助制造(CAD/CAM)}}这些领域使用计算机技术在计算机上设计零件和产品，然后使用这些虚拟设计来指导制造过程。例如，许多机械零件在3D计算机建模软件中设计，然后在计算机控制的铣削设备上自动生产。
	
	\item \textbf{\textcolor{ForestGreen}{仿真模拟(Simulation)}}可以被认为是精确的游戏。例如，飞行模拟器使用复杂的3D图形来模拟驾驶飞机的体验。这种模拟对于安全关键领域(如驾驶)的初始培训以及有经验用户的情景培训(如成本太高或太危险而无法实际创建的特定消防情况)非常有用。
	
	\item \textbf{\textcolor{ForestGreen}{医学成像(Medical imaging)}}通过扫描患者产生的数据创建有价值的图像。例如，计算机断层扫描(CT)数据集由大型3D密度值矩阵组成。计算机图形学被用来创建阴影图像，帮助医生从这些数据中提取最重要的信息。
	
	\item \textbf{\textcolor{ForestGreen}{信息可视化(Information visualization)}}创建的数据图像不一定具有“自然”的视觉描述。例如，十种不同股票价格的时间趋势没有明显的视觉描述，但巧妙的图形技术可以帮助人类看到这些数据中的模式。
\end{itemize}


\section{图形应用程序接口(Graphics APIs)}

使用图形库的一个关键部分是处理图形API。应用程序接口(API)是执行一组相关操作的标准函数集合，图形API是执行基本操作的一组函数，例如将图像和3D表面绘制到屏幕上的窗口中。

每个图形程序都需要能够使用两个相关的API:一个用于可视化输出的图形API和一个用于获取用户输入的用户界面API。目前，图形和用户界面API有两种主流模式。第一种是集成方法，以Java为例，其中图形和用户界面工具包是集成的、可移植的包，完全标准化并作为语言的一部分得到支持。第二种以Direct3D和OpenGL为代表，其中绘图命令是与C++等语言相关的软件库的一部分，用户界面软件是一个独立的实体，可能因系统而异。在后一种方法中，编写可移植代码是有问题的，尽管对于简单的程序，可以使用可移植库层来封装系统特定的用户界面代码。

无论选择哪种API，基本的图形调用基本上都是一样的，本书的概念也适用。

\section{图形管线(Graphics Pipeline)}

如今，每台台式电脑都有强大的3D图形管道。这是一个特殊的软件/硬件子系统，可以有效地绘制透视图中的三维图元。通常，这些系统针对处理具有共享顶点的3D三角形进行了优化。管线中基本操作是将三维的顶点位置映射到二维的屏幕位置，并对三角形进行着色，以使它们看起来真实，并以正确的前后顺序显示。

尽管以正确的前后顺序绘制三角形曾经是计算机图形学中最重要的研究问题，但现在大多是使用深度缓冲(z-buffer)来解决，其使用一种特殊的内存缓冲区，并且以暴力方式解决问题。

事实证明，在图形管线中使用的几何操作几乎完全可以在4D坐标空间中完成，该空间由3D坐标和有利于透视观察(perspective viewing)的第四个齐次坐标(homogeneous coordinate)组成。这些4D坐标使用4 × 4矩阵和4个向量来操作。因此，图形管线中包含许多用于高效处理这种矩阵和向量的计算单元。这个4D坐标系是计算机科学中使用的最微妙和最美丽的构造之一，它当然是学习计算机图形学时要跳过的最大的障碍。每本图形学书第一部分的很多内容都是关于4D坐标的。

生成图像的速度很大程度上取决于绘制三角形的数量。因为在许多应用程序中，交互性比视觉效果更重要，所以尽量减少用于表示模型的三角形数量是值得的。此外，如果从远处观察模型，比从近处观察模型需要更少的三角形。这表明用多细节层次(level of detail,LOD)来表示模型是有用的。

\section{数值问题(Numerical Issues)}

许多图形程序实际上只是3D数值代码。在这样的程序中，数值问题通常是至关重要的。在“过去”，以健壮和可移植的方式处理这样的问题是非常困难的，因为机器对数有不同的内部表示，更糟糕的是，处理异常的方式不同，且不兼容。幸运的是，几乎所有的现代计算机都符合IEEE浮点标准(IEEE Standards Association，1985)。这使得程序员可以对如何处理某些数字条件做出许多方便的假设。

虽然IEEE浮点有很多特性，在编码数字算法时很有价值，但在图形学中遇到的大多数情况下，只有少数几个特性是必须知道的。首先，也是最重要的一点，就是要了解IEEE浮点中的实数有三个“特殊”值:

\begin{enumerate}
	\item \textcolor{ForestGreen}{无穷大(Infinity,$\infty$)}这是一个有效的数字，比其他所有有效的数字都大。
	
	\item \textcolor{ForestGreen}{负无穷大(Minus infinity,$-\infty$)}这是一个有效的数字，比其他所有的有效数字都小。
	
	\item \textcolor{ForestGreen}{非数值形式(NaN)}这是一个无效的数字，产生于一个后果未定的操作，如零除以零。
\end{enumerate}


IEEE浮点的设计者做出了一些非常方便程序员的决定。其中许多与上述三个特殊值有关，用于处理除零等异常。在这些情况下，会记录一个异常，但在许多情况下，程序员可以忽略它。具体来说，对于任何正实数$a$，以下涉及除以无限值的规则成立\footnote{IEEE浮点有两种零的表示方法，一种是被视为正数，一种是被视为负数。虽然-0和+0之间的区别只是偶尔会出现，但在出现时还是值得记住的。}：


\begin{equation}
	\begin{aligned}	
		+a/(+\infty)=+0 \\
		-a/(+\infty)=-0 \\
		+a/(-\infty)=-0 \\
		-a/(-\infty)=+0 \\
	\end{aligned}
	\nonumber	
\end{equation}

其他涉及无限值的操作的行为也是可预测的。同样对于正数$a$，行为如下:

\begin{equation}
	\begin{aligned}	
		\infty+\infty&=+\infty\\
		\infty-\infty&= \rm NaN\\
		\infty*\infty&=\infty\\
		\infty/\infty&= \rm NaN \\
		\infty/a&=\rm NaN \\
		\infty/0&=\rm NaN \\
		0/0&=\rm NaN \\
	\end{aligned}
	\nonumber	
\end{equation}

布尔表达式中涉及无限值的规则如下所示:

\begin{enumerate}
	\item 所有有限的有效数字都小于正无穷。
	\item 所有有限的有效数字都大于负无穷。
	\item 负无穷比正无穷小。
\end{enumerate}

涉及有NaN值的表达式的规则很简单：

\begin{enumerate}
	\item 任何包含NaN的算术表达式的结果都是NaN。
	
	\item 任何涉及NaN的布尔表达式都是假的。
\end{enumerate}

IEEE浮点数最有用的方面也许是如何处理除以零的问题；对于任何正实数$a$，以下涉及除以零的规则是成立的:

\begin{equation}
	\begin{aligned}	
		+a/+0=+	\infty\\
		-a/+0=-	\infty
	\end{aligned}
\nonumber
\end{equation}

如果程序员利用IEEE规则，有许多数字计算会变得简单得多。例如，考虑表达式:

\begin{equation}\label{key}
	\begin{aligned}	
		a=\frac{1}{\frac{1}{b}+\frac{1}{c}}
	\end{aligned}
\nonumber
\end{equation}

电阻器和透镜会产生这样的表达式。如果除以零导致程序崩溃(在IEEE浮点之前的许多系统中都是如此)，则需要两个If语句来检查$b$或$c$是否是小值或零值。相反，在IEEE浮点中，如果$b$或$c$为零，我们将根据需要获得$a$的零值。另一种避免特殊检查的常见技术是利用NaN的布尔属性。考虑以下代码段：

\begin{equation}\label{key}
	\begin{aligned}	
		&a=f(x)\\
		&\mathbf{if}(a>0)\mathbf{then}\\
		&\quad do \: something
	\end{aligned}
\nonumber
\end{equation}

在这里，函数f可能会返回“很差的”值，如$\infty$或$\rm NaN$，但$if$条件仍然是定义明确的：当$a=\rm NaN$或$a=-\infty$时为假，$a=+\infty$时为真。在决定返回哪些值时要小心，通常$if$可以做出正确的选择，而不需要特别的检查。这使得程序更短小，更健壮，更有效率。

\section{有效性(Efficiency)} 

要使代码更有效率没有神奇的规则。效率是通过谨慎的权衡来实现的，而这些权衡对于不同的架构是不同的。然而，在可预见的未来，程序员应该更加关注内存访问模式(memory access patterns)而不是操作计数(operation counts)。
这与20年前的最佳启发式算法相反。出现这种转换是因为内存的速度没有跟上处理器的速度。由于这一趋势仍在继续，有限和连贯的内存访问对优化的重要性会只增不减。

使代码快速运行的合理方法就是进行按照以下顺序的步骤：
\begin{enumerate}
	\item 尽可能以最直接的方式编写代码, 根据需要及时计算中间结果，而不是存储它们。
	\item 在优化模式下进行编译。
	\item 使用现有的任何分析工具来查找关键瓶颈。
	\item 检查数据结构以寻找进行局部优化的方法。如果可以的话，使数据单元大小与目标体系结构上的页缓存(cache/page)大小相匹配。
	\item 如果分析揭示了数值计算中的瓶颈，请检查编译器生成的汇编代码是否有效率缺失。重写代码以解决发现的任何问题。
\end{enumerate}

这些步骤中最重要的是第一步。大多数“优化”使代码更难阅读，而不会加快速度。此外，前期优化代码所花费的时间通常比修正错误或添加功能所花费的时间更有价值。此外，要注意来自旧文本的建议；一些经典的技巧(例如使用整数而不是实数)可能不再产生加速效果，因为现代CPU通常可以像执行整数运算一样快速地执行浮点运算。在所有情况下，都需要进行分析，以确定任何优化对特定机器和编译器的好处。

\section{设计和编码图形程序(Designing and Coding Graphics Programs)}

某些常用的策略在图形编程中通常很有用。在本节中，我们提供了一些建议，当您实施本书中学习的方法时，这些建议可能会有所帮助。

\subsection{类设计(Class Design)}

任何图形程序的关键部分都是为几何实体(如向量和矩阵)以及图形实体(如RGB颜色和图像)提供良好的类或程序。这些程序应该尽可能地简洁和高效。一个常见的设计问题是位置和位移是否应该是单独的类，因为它们有不同的操作\footnote{我坚信KISS(keep it simple, stupid)原则，因此，两个类的论证不足以证明增加的复杂性。-P.S.}\footnote{我喜欢将点和向量分开，因为这样可以使代码更可读，并且可以让编译器捕获一些错误。-S.M.}，例如，位置乘以$1/2$没有几何意义，而位移乘以$1/2$有几何意义(Goldman, 1985;DeRose, 1989)。在这个问题上几乎没有达成一致意见，这可能会在图形从业者之间引发数小时的激烈辩论，但为了举例，我们假设我们不进行区分。

这意味着要编写的一些基本类包括:

\begin{itemize}
	\item  \textcolor{ForestGreen}{vector2} 一个二维向量类，它存储一个x和y分量。它应该将这些标量成员存储在长度为2的数组中，以便能够很好地支持索引运算符。还应该包括向量加法、向量减法、点乘、叉乘、标量乘法和标量除法的运算。
	
	\item  \textcolor{ForestGreen}{Vector3} 一个类似于vector2的3D向量类。
	
	\item  \textcolor{ForestGreen}{Hvector} 具有四个分量的齐次向量(见第\ref{chap08}章)。
	
	\item  \textcolor{ForestGreen}{rgb} 一种RGB颜色，存储三个标量成员。还应该包括RGB加法，RGB减法，RGB乘法，标量乘法和标量除法的操作。
	
	\item  \textcolor{ForestGreen}{Transform} 一个用于变换的4 × 4矩阵。你应该包含矩阵乘法和以应用于位置、方向和表面法向量的成员函数。如第\ref{chap07}章所示，这些都是不同的。
	
	\item  \textcolor{ForestGreen}{Image} 带有输出操作的RGB像素的2D数组。
\end{itemize}

此外，您可能希望也可能不希望为间隔、正交基和坐标系添加类。

\subsection{单精度浮点VS双精度浮点(Float vs. Double)} 

现代架构表明，降低内存使用量和保持一致的内存访问是提高效率的关键。这就建议使用单精度数据。然而，为了避免数值问题，建议使用双精度算法。如何取舍取决于程序，但是最好在类的定义中有一个默认值。

\subsection{调试图形程序(Debugging Graphics Programs)} 

如果您四处询问，您可能会发现随着程序员越来越有经验，他们使用传统调试器的次数越来越少。这样做的一个原因是，在复杂的程序中使用这样的调试器比在简单的程序中使用更为困难。另一个原因是，最困难的错误是概念上的错误，其中实现了错误的东西，很容易浪费大量的时间在逐级检查变量值而没有检测到这种情况。我们发现几种调试策略在图形中特别有用:

\subsubsection*{\textcolor{structure3}{科学的方法(The Scientific Method)}}

在图形程序中，有一种替代传统调试的方法，通常非常有用。它的缺点是，这非常类似于计算机程序员在职业生涯早期被教导不要做的事情，所以如果你这样做，你可能会觉得“顽皮”:我们创建一个图像，然后观察它有什么问题。然后，我们提出一个关于问题原因的假设，并对其进行验证。例如，在光线追踪程序中，我们可能会有许多看起来有点随机的深色像素。这是大多数人在编写射线跟踪程序时会遇到的典型“shadow acne”问题。传统的调试在这里没有帮助;相反，我们必须意识到阴影射线击中表面被遮蔽。我们可能会注意到黑点的颜色是环境色，所以缺少的是直接照明。直接照明可以在阴影中关闭，所以您可能会假设这些点被错误地标记为阴影中，而实际上它们并不是。为了验证这个假设，我们可以关闭跟踪检查并重新编译。这将表明这些是假的阴影测试，我们可以继续我们的假设工作。这种方法有时是很好的实践的关键原因是，我们从来不必发现错误的值或真正确定我们的概念错误。

相反，我们只是缩小了实验上的概念错误。通常只需要进行几次试验就可以跟踪问题，而且这种类型的调试是令人愉快的。

\subsubsection*{\textcolor{structure3}{Images as Coded Debugging Output}}
在许多情况下，从图形程序中获取调试信息的最简单的通道就是输出图像本身。如果你想知道某个变量的值，在每个像素运行的计算中，你可以临时修改你的程序，直接将该值复制到输出图像中，并跳过通常需要完成的其他计算。例如，如果您怀疑曲面法线的问题导致了阴影的问题，您可以直接将法向量复制到图像中(x变为红色，y变为绿色，z变为蓝色)，从而生成计算中实际使用的向量的彩色插图。或者，如果您怀疑某个特定值有时超出了它的有效范围，那么让您的程序在发生这种情况的地方编写鲜红色像素。

其他常见的技巧包括用明显的颜色绘制表面的背面(当它们不应该可见时)，根据物体的ID号为图像着色，或根据计算所需的工作量为像素着色。

\subsubsection*{\textcolor{structure3}{Using a Debugger}}

仍然有一些情况，特别是当科学方法似乎导致矛盾的时候，当没有任何替代方法可以精确观察正在发生的事情时。问题是，图形程序经常涉及到对相同代码的多次执行(例如，每个像素执行一次，或每个三角形执行一次)，这使得从一开始就在调试器中逐级执行完全不切实际。最困难的bug通常只发生在复杂的输入中。

一个有用的方法是为bug“设置一个陷阱”。首先，确保您的程序是确定性的——在单个线程中运行它，并确保所有随机数都是从固定的种子计算出来的。然后，找出哪个像素或三角形显示了错误，并在您怀疑是错误的代码之前添加一条语句，该语句只会在可疑的情况下执行。例如，如果你发现像素(126,247)显示了错误，然后添加:
\begin{equation}
	\begin{aligned}	
		fx &= 126\:and\:y=247\:then \\
		&print"bl\:arg!"
	\end{aligned}
\end{equation}

如果在print语句上设置了断点，那么就可以在计算感兴趣的像素之前进入调试器。一些调试器具有“条件断点”特性，可以在不修改代码的情况下实现相同的功能。
在程序崩溃的情况下，传统的调试器对于确定崩溃的位置非常有用。然后你应该在程序中开始回溯，使用断言和重新编译，以找到程序出错的地方。这些断言应该保留在程序中，以应对将来可能添加的错误。这再次意味着避免了传统的分步过程，因为这样就不会向程序中添加有价值的断言。

\subsubsection*{\textcolor{structure3}{用于调试的数据可视化(Data Visualization for Debugging)}}

通常情况下是很难理解你的程序在做什么，因为它在最终出错之前会计算很多中间结果。情况类似于测量大量数据的科学实验，其解决方案是:为自己制作好的图表和插图，以理解数据的含义。

例如，在光线跟踪器中，你可以编写代码来可视化光线树，以便你可以看到哪些路径对像素有贡献，或者在图像重采样过程中，你可以绘制显示从输入中获取样本的所有点的图。花费时间编写代码来可视化程序内部状态，在优化它的时候，也可以更好地理解它的行为得到反馈。（将调试输出语句格式化，生成matlab或Gnuplot脚本可以绘制一些有用的图）

\section*{备注(Notes)}

我们可以在网络上找到关于计算机图形学有关的年度会议，如ACM SIGGRAPH和SIGGRAPH Asia、Graphics Interface、Game Developers Conference (GDC)、Eurographics、Pacific Graphics、High Performance Graphics、Eurographics Symposium on Rendering以及IEEE VisWeek。



